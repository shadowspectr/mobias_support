import asyncio
import logging
import os
from aiogram import Bot, Dispatcher, types
from aiogram.types import ContentType, Message
from aiogram.filters.command import Command
from aiogram.exceptions import TelegramAPIError
from dotenv import load_dotenv
from keyboard import get_start_keyboard
from aiogram.types import ReplyKeyboardRemove
from callback_handler import callback_router
from middlewares.log_user import UserLoggingMiddleware
import pandas as pd
from geopy.distance import geodesic
from aiogram import Router, F
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
import keep_alive
from support_handler import callback_router as support_router
from partner_handler import partner_router
from src.broadcast import send_random_ad
from src.broadcast import send_ad_to_user

load_dotenv()

BOT_TOKEN = os.getenv('API_KEY')
USER_IDS_FILE = "user_ids.txt"

def load_user_ids():
    try:
        if not os.path.exists(USER_IDS_FILE):
            with open(USER_IDS_FILE, "w") as f:
                pass
            logging.info("–°–æ–∑–¥–∞–Ω –Ω–æ–≤—ã–π —Ñ–∞–π–ª user_ids.txt")
            return set()
        with open(USER_IDS_FILE, "r") as file:
            return set(line.strip() for line in file if line.strip().isdigit())
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ user_ids.txt: {e}")
        return set()

def save_user_id(user_id: int):
    try:
        user_ids = load_user_ids()
        if str(user_id) not in user_ids:
            with open(USER_IDS_FILE, "a") as file:
                file.write(f"{user_id}\n")
            logging.info(f"–î–æ–±–∞–≤–ª–µ–Ω –Ω–æ–≤—ã–π user_id: {user_id}")
        else:
            logging.info(f"user_id {user_id} —É–∂–µ –≤ —Å–ø–∏—Å–∫–µ")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ user_id {user_id}: {e}")

logging.basicConfig(level=logging.INFO)

bot = Bot(token=BOT_TOKEN)
dp = Dispatcher()

dp.message.middleware(UserLoggingMiddleware())
dp.callback_query.middleware(UserLoggingMiddleware())
dp.include_router(partner_router)
dp.include_router(callback_router)
dp.include_router(support_router)  # –†–æ—É—Ç–µ—Ä –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–∫–ª—é—á–µ–Ω
df = pd.read_excel('map.xlsx')
router = Router()

# ID —á–∞—Ç–∞ —Ç–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫–∏
SUPPORT_CHAT_ID = -1002837608854
KNOWN_BUTTON_TEXTS = {
    "üì¶ –ö–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –¥–æ—Å—Ç–∞–≤–∫–æ–π?",
    "‚ÑπÔ∏è –ö–∞–∫ –æ–ø–ª–∞—Ç–∏—Ç—å –¥–æ—Å—Ç–∞–≤–∫—É?",
    "‚ÑπÔ∏è –ö–∞–∫ –æ—Ç–∫—Ä—ã—Ç—å —Å–≤–æ–π –ø—É–Ω–∫—Ç –≤—ã–¥–∞—á–∏?",
    "üìç –ù–∞–π—Ç–∏ –ø—É–Ω–∫—Ç –≤—ã–¥–∞—á–∏ –ø–æ–±–ª–∏–∑–æ—Å—Ç–∏",
    "‚ùì –û–±—Ä–∞—Ç–∏—Ç—å—Å—è –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É",
    "üè¨ –ê–¥—Ä–µ—Å–∞ –º–∞–≥–∞–∑–∏–Ω–æ–≤",
    "üéÅ –ê–∫—Ç—É–∞–ª—å–Ω—ã–µ –∞–∫—Ü–∏–∏"
}

# –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è FSM (–æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –≤ main.py)
class SupportState(StatesGroup):
    waiting_for_question = State()

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start
@dp.message(Command("start"))
async def cmd_start(message: types.Message):
    save_user_id(message.from_user.id)  # –°–æ—Ö—Ä–∞–Ω—è–µ–º ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    await message.answer("–û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å...", reply_markup=ReplyKeyboardRemove())
    await message.answer("–ü—Ä–∏–≤–µ—Ç - –ø—Ä–∏–≤–µ—Ç üëã \n"
                         "–Ø –±–æ—Ç –º–∞–≥–∞–∑–∏–Ω–∞ —Ü–∏—Ñ—Ä–æ–≤–æ–π –ø—Ä–æ–¥—É–∫—Ü–∏–∏ 'MobiAs'! \n"
                         "–ó–∞–¥–∞–≤–∞–π —Å–≤–æ–∏ –≤–æ–ø—Ä–æ—Å—ã, –º—ã –≤—Å–µ–≥–¥–∞ –±—É–¥–µ–º —Ä–∞–¥—ã –ø–æ–º–æ—á—å!",
                         reply_markup=get_start_keyboard(), parse_mode="HTML")

@dp.message(Command("list"))
async def list_user_ids(message: types.Message):
    user_ids = load_user_ids()
    if not user_ids:
        await message.answer("–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø—É—Å—Ç.")
    else:
        await message.answer("–°–ø–∏—Å–æ–∫ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:\n" + "\n".join(user_ids))

@dp.message(Command("broadcast"))
async def broadcast_ads(message: types.Message):
    await message.answer("–†–∞—Å—Å—ã–ª–∞—é —Ä–µ–∫–ª–∞–º—É...")
    await send_random_ad(bot)

@dp.message(F.text == "üè¨ –ê–¥—Ä–µ—Å–∞ –º–∞–≥–∞–∑–∏–Ω–æ–≤")
async def show_shop_addresses(message: types.Message):
    addresses = (
        "üìç <b>–ì. –ú–µ–ª–∏—Ç–æ–ø–æ–ª—å, –ü—Ä-—Ç –ë. –•–º–µ–ª—å–Ω–∏—Ü–∫–æ–≥–æ 24</b>\n"
        "üè¢ –¢–¶ –ü–∞—Å—Å–∞–∂, –≤—Ö–æ–¥ 2\n"
        "‚è∞ –° 9:00 –¥–æ 17:00\n\n"
        "üìç <b>–ì. –ú–µ–ª–∏—Ç–æ–ø–æ–ª—å, –ü—Ä-—Ç –ë. –•–º–µ–ª—å–Ω–∏—Ü–∫–æ–≥–æ 30</b>\n"
        "‚è∞ –° 9:00 –¥–æ 18:00\n\n"
        "üìç <b>–ì. –ú–µ–ª–∏—Ç–æ–ø–æ–ª—å, —É–ª. –ö–∏—Ä–æ–≤–∞ 94</b>\n"
        "üè¢ –¢–¶ –õ—é–∫—Å, 1-–π —ç—Ç–∞–∂\n"
        "‚è∞ –° 9:00 –¥–æ 18:00"
    )
    await message.answer(addresses, parse_mode="HTML")

@dp.message(F.text == "üéÅ –ê–∫—Ç—É–∞–ª—å–Ω—ã–µ –∞–∫—Ü–∏–∏")
async def handle_promotions(message: types.Message, bot: Bot):
    await send_ad_to_user(bot, message.from_user.id)

@dp.callback_query(lambda c: c.data == "open_main")
async def process_open_main(callback: types.CallbackQuery):
    await callback.answer()
    await callback.message.answer("–û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å...", reply_markup=ReplyKeyboardRemove())
    await callback.message.answer(
        "–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤—É—é! –Ø –±–æ—Ç +7–î–æ—Å—Ç–∞–≤–∫–∏. –†–∞—Å—Å–∫–∞–∂—É, –∫–∞–∫ –±–µ—Å–ø–ª–∞—Ç–Ω–æ –ø–æ–ª—É—á–∞—Ç—å —Ç–æ–≤–∞—Ä—ã —Å "
        "<a href='https://www.ozon.ru/'>—Ç–æ–ø–æ–≤–æ–≥–æ –º–∞—Ä–∫–µ—Ç–ø–ª–µ–π—Å–∞ –†–§</a>.",
        reply_markup=get_start_keyboard(),
        parse_mode="HTML"
    )

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –∫–Ω–æ–ø–∫–∏ "–û–±—Ä–∞—Ç–∏—Ç—å—Å—è –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É" (—Ç–µ–∫—Å—Ç–æ–≤–æ–π)
@dp.message(F.text == "‚ùì –û–±—Ä–∞—Ç–∏—Ç—å—Å—è –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É")
async def support_redirect(message: types.Message, state: FSMContext):
    await message.answer("üõ† –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–ø–∏—à–∏—Ç–µ –≤–∞—à—É –ø—Ä–æ–±–ª–µ–º—É –∏–ª–∏ –∑–∞–¥–∞–π—Ç–µ –≤–æ–ø—Ä–æ—Å.")
    await state.set_state(SupportState.waiting_for_question)

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤–æ–ø—Ä–æ—Å–æ–≤ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ –æ–∂–∏–¥–∞–Ω–∏—è
@dp.message(SupportState.waiting_for_question)
async def handle_support_question(message: types.Message, state: FSMContext, bot: Bot):
    try:
        # 1. –ö–æ–ø–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É
        copied_msg = await message.copy_to(chat_id=SUPPORT_CHAT_ID)
        
        # 2. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∫–∞–∫ reply –∫ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–Ω–æ–º—É —Å–æ–æ–±—â–µ–Ω–∏—é
        await bot.send_message(
            SUPPORT_CHAT_ID, 
            f"[ID:{message.from_user.id}] @{message.from_user.username or '–Ω–µ—Ç_username'}",
            reply_to_message_id=copied_msg.message_id
        )
        
        await message.answer("–í–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ —Ç–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫—É üí¨\n–°–∫–æ—Ä–æ —Å –≤–∞–º–∏ —Å–≤—è–∂–µ—Ç—Å—è —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç.")
        await state.clear()
        
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É: {e}")
        await message.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—Ç–≤–µ—Ç–æ–≤ –∏–∑ —á–∞—Ç–∞ –ø–æ–¥–¥–µ—Ä–∂–∫–∏
@dp.message(lambda message: message.chat.id == SUPPORT_CHAT_ID)
async def handle_support_responses(message: types.Message, bot: Bot):
    try:
        # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç –±–æ—Ç–∞
        if message.from_user.is_bot:
            return
            
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –æ—Ç–≤–µ—Ç—ã (reply)
        if not message.reply_to_message:
            return
            
        user_id = None
        
        # –ï—Å–ª–∏ –æ—Ç–≤–µ—á–∞—é—Ç –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å [ID:...]
        if message.reply_to_message.text and message.reply_to_message.text.startswith("[ID:"):
            try:
                id_part = message.reply_to_message.text.split("]")[0][4:]
                user_id = int(id_part)
            except (ValueError, IndexError):
                pass
        
        # –ï—Å–ª–∏ –æ—Ç–≤–µ—á–∞—é—Ç –Ω–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è,
        # –∏—â–µ–º —Å–≤—è–∑–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å ID (–∫–æ—Ç–æ—Ä–æ–µ –±—ã–ª–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –∫–∞–∫ reply)
        elif message.reply_to_message.reply_to_message and message.reply_to_message.reply_to_message.text:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ reply –∫ replied —Å–æ–æ–±—â–µ–Ω–∏—é —Å ID
            reply_text = message.reply_to_message.reply_to_message.text
            if reply_text.startswith("[ID:"):
                try:
                    id_part = reply_text.split("]")[0][4:]
                    user_id = int(id_part)
                except (ValueError, IndexError):
                    pass
        
        if user_id:
            # –ü–µ—Ä–µ—Å—ã–ª–∞–µ–º –æ—Ç–≤–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
            await message.copy_to(chat_id=user_id)
            
            # –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –≤ —á–∞—Ç –ø–æ–¥–¥–µ—Ä–∂–∫–∏
            await bot.send_message(
                SUPPORT_CHAT_ID,
                f"‚úÖ –û—Ç–≤–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}",
                reply_to_message_id=message.message_id
            )
            logging.info(f"–û—Ç–≤–µ—Ç –ø–µ—Ä–µ—Å–ª–∞–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}")
        else:
            await bot.send_message(
                SUPPORT_CHAT_ID,
                "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–æ–ª—É—á–∞—Ç–µ–ª—è. –û—Ç–≤–µ—Ç—å—Ç–µ –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å [ID:...]"
            )
            
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—Ç–≤–µ—Ç–∞ –ø–æ–¥–¥–µ—Ä–∂–∫–∏: {e}")

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –≤–µ–±—Ö—É–∫–∞
async def delete_webhook():
    try:
        await bot.delete_webhook()
        logging.info("–í–µ–±—Ö—É–∫ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω")
    except TelegramAPIError as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –≤–µ–±—Ö—É–∫–∞: {e}")

# –§—É–Ω–∫—Ü–∏—è –ø–æ–∏—Å–∫–∞ –±–ª–∏–∂–∞–π—à–∏—Ö –ø—É–Ω–∫—Ç–æ–≤
def get_nearby_locations(user_location, max_distance_km=2):
    nearby_locations = []
    priority_location = "–î–æ–Ω–µ—Ü–∫, –ø–ª. –ö–æ–Ω—Å—Ç–∏—Ç—É—Ü–∏–∏, –¥.4"

    for index, row in df.iterrows():
        location = (row['—à–∏—Ä–æ—Ç–∞'], row['–¥–æ–ª–≥–æ—Ç–∞'])
        distance = geodesic(user_location, location).kilometers
        if distance <= max_distance_km:
            is_priority = row['–∞–¥—Ä–µ—Å'] == priority_location
            nearby_locations.append((row['–∞–¥—Ä–µ—Å'], distance, row['—Å—Å—ã–ª–∫–∞'], row['—à–∏—Ä–æ—Ç–∞'], row['–¥–æ–ª–≥–æ—Ç–∞'], is_priority))

    return sorted(nearby_locations, key=lambda x: (not x[5], x[1]))

@dp.message(F.content_type == ContentType.LOCATION)
async def handle_location(message: Message):
    logging.info(f"–ü–æ–ª—É—á–µ–Ω–∞ –≥–µ–æ–ø–æ–∑–∏—Ü–∏—è: {message.location.latitude}, {message.location.longitude}")
    user_location = (message.location.latitude, message.location.longitude)
    nearby_locations = get_nearby_locations(user_location)

    if nearby_locations:
        response = "<b>–í–æ—Ç –±–ª–∏–∂–∞–π—à–∏–µ –∫ –≤–∞–º –ø—É–Ω–∫—Ç—ã –≤—ã–¥–∞—á–∏:</b>\n\n"
        for address, distance, link, lat, lon, is_priority in nearby_locations:
            yandex_maps_url = f"https://yandex.ru/maps/?ll={lon},{lat}&z=16&mode=search&text={address}"
            response += f"üìç <b>{address}</b> - {distance:.2f} –∫–º\n"
            response += f"üîó <a href='{link}'>–î–æ–±–∞–≤–∏—Ç—å –ø—É–Ω–∫—Ç –≤—ã–¥–∞—á–∏ –≤ Ozon</a>\n"
            response += f"üó∫Ô∏è <a href='{yandex_maps_url}'>–û—Ç–∫—Ä—ã—Ç—å –≤ –Ø–Ω–¥–µ–∫—Å.–ö–∞—Ä—Ç–∞—Ö</a>\n\n"
    else:
        response = "–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –≤ —Ä–∞–¥–∏—É—Å–µ 2 –∫–º –Ω–µ—Ç —Ç–æ—á–µ–∫."

    await message.reply(response, parse_mode="HTML")

# Fallback –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π (–∏—Å–∫–ª—é—á–∞–µ–º —á–∞—Ç –ø–æ–¥–¥–µ—Ä–∂–∫–∏)
@dp.message(lambda message: message.chat.id != SUPPORT_CHAT_ID)
async def fallback_handler(message: types.Message, bot: Bot):
    # –ï—Å–ª–∏ —Ç–µ–∫—Å—Ç —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –∏–∑–≤–µ—Å—Ç–Ω—ã–º–∏ –∫–Ω–æ–ø–∫–∞–º–∏ ‚Äî –Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º
    if message.text and message.text.strip() in KNOWN_BUTTON_TEXTS:
        return

    # –ü–µ—Ä–µ—Å—ã–ª–∞–µ–º –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —Ç–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫—É
    try:
        await message.forward(chat_id=SUPPORT_CHAT_ID)
        await bot.send_message(
            SUPPORT_CHAT_ID,
            f"[ID:{message.from_user.id}] @{message.from_user.username or '–Ω–µ—Ç_username'} - –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –ø–µ—Ä–µ—Å—ã–ª–∫–∞"
        )
        await message.answer("–í–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–µ—Ä–µ–¥–∞–Ω–æ –≤ —Å–ª—É–∂–±—É –ø–æ–¥–¥–µ—Ä–∂–∫–∏ üí¨\n"
                           "–ú—ã —Å–≤—è–∂–µ–º—Å—è —Å –≤–∞–º–∏ –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è!")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Å—ã–ª–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")

dp.include_router(router)

# –§—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞
async def main():
    await delete_webhook()
    try:
        await dp.start_polling(bot)
    except TelegramAPIError as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞: {e}")

if __name__ == "__main__":
    keep_alive.keep_alive()
    asyncio.run(main())